CCS PCD C Compiler, Version 4.104, 5967               18-Nov-15 21:29

               Filename: C:\Users\e882742\Documents\Robotica\BabyFaraday-V3.0.git\main.lst

               ROM used: 2502 bytes (6%)
                         Largest free fragment is 42554
               RAM used: 247 (12%) at main() level
                         258 (13%) worst case
               Stack:    1 locations

*
0000:  GOTO    766
.................... #include <30f5015.h> 
.................... //////// Standard Header file for the DSPIC30F5015 device //////////////// 
.................... #device DSPIC30F5015 
.................... #list 
....................  
.................... #include "Config.h" 
.................... #DEVICE ADC=10 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES FRC_PLL16                //Internal Fast RC oscillator with 16X PLL 
.................... //#FUSES FRC_PLL8               //Internal Fast RC oscillator with 8X PLL 
.................... #FUSES PR_PLL                   //Primary Oscillator with PLL 
.................... #FUSES NOCKSFSM                 //Clock Switching is disabled, fail Safe clock monitor is disabled 
.................... #FUSES WPSB16                   //Watch Dog Timer PreScalar B 1:16 
.................... #FUSES WPSA512                  //Watch Dog Timer PreScalar A 1:512 
.................... #FUSES PUT64                    //Power On Reset Timer value 64ms 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORRES                 
.................... #FUSES LPOL_HIGH                //Low-Side Transistors Polarity is Active-High (PWM 0,2,4 and 6) 
....................    //PWM module low side output pins have active high output polar 
.................... #FUSES HPOL_HIGH                //High-Side Transistors Polarity is Active-High (PWM 1,3,5 and 7) 
....................    //PWM module high side output pins have active high output polarity 
.................... #FUSES NOPWMPIN                 //PWM outputs drive active state upon Reset 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOCOE                    //Device will reset into operational mode 
.................... //#FUSES ICSP1                    //ICD uses PGC1/PGD1 pins 
.................... #use delay(clock=117920000) 
*
013E:  CP0     W0
0140:  BTSC.B  42.1
0142:  BRA     150
0144:  REPEAT  #3321
0146:  NOP     
0148:  REPEAT  #3FFF
014A:  NOP     
014C:  DEC     W0,W0
014E:  BRA     13E
0150:  RETURN  
*
0756:  CP0     W0
0758:  BTSC.B  42.1
075A:  BRA     764
075C:  REPEAT  #16
075E:  NOP     
0760:  DEC     W0,W0
0762:  BRA     756
0764:  RETURN  
.................... //#use delay(clock=58960000) 
.................... //#use rs232(UART1,baud=115200,bits=8, xmit=PIN_F3,rcv=PIN_F2, parity=N, TIMEOUT=5000) 
.................... #DEFINE PWM_PERIOD 	1499 
.................... #DEFINE SET_POINT	16 
....................  
.................... #include "Global_Variables.c" 
....................  
.................... int16 sensors_ADC[15],black_limit=730; 
.................... int16   center_der=0,sensors_BIN[15],base_speed=700,left_correction,right_correction,last_center=16,center,last_error,error,derivative,correction; 
.................... float   integral=0,KD=450,KP=70,KI=8; 
.................... int RUN=0xFF;// 
.................... int16 x=0,delay_time=16000,BoostCounter=0; 
.................... //KD=0,KP=125,KI=0,BaseSpeed=700 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
07A2:  CLR     86A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "Functions.h" 
.................... #include "Functions.c" 
....................  
.................... void ADC_Init(void) 
.................... { 
.................... 	setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN5|sAN6|sAN7|sAN8|sAN9|sAN10|sAN11|sAN15);//sAN12|sAN13|sAN14|sAN15);//*******Setup ch0 and ch1 as ADC inputs in Px and Py****** 
*
0100:  MOV     #7000,W4
0102:  MOV     W4,2A8
0104:  CLR     2A2
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
0106:  MOV     #80,W4
0108:  MOV     W4,2A4
010A:  MOV     #80E0,W4
010C:  MOV     W4,2A0
.................... } 
010E:  RETURN  
....................  
.................... void Motor_Init(int16 period) 
.................... { 
....................     setup_compare(1, COMPARE_PWM | COMPARE_TIMER3); 			// en OC1 pin 46 M1        
0110:  MOV     #E,W4
0112:  MOV     W4,184
....................     setup_compare(2, COMPARE_PWM | COMPARE_TIMER2); 			// en OC2 pin 49 M1 
0114:  MOV     #6,W4
0116:  MOV     W4,18A
....................     setup_compare(3, COMPARE_PWM | COMPARE_TIMER3); 			// en OC3 pin 50 M2       
0118:  MOV     #E,W4
011A:  MOV     W4,190
....................    	setup_compare(4, COMPARE_PWM | COMPARE_TIMER3); 			// en OC4 pin 51 M2 
011C:  MOV     #E,W4
011E:  MOV     W4,196
....................   
....................     setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1,PWM_PERIOD );  
0120:  CLR     110
0122:  MOV     #5DB,W4
0124:  MOV     W4,10C
0126:  MOV     #A000,W4
0128:  MOV     W4,110
....................     setup_timer3(TMR_INTERNAL | TMR_DIV_BY_1,PWM_PERIOD ); 
012A:  CLR     112
012C:  MOV     #5DB,W4
012E:  MOV     W4,10E
0130:  MOV     #A000,W4
0132:  MOV     W4,112
....................  
....................     set_pwm_duty(1, 0);    										// M2 Duty 0%   LEFT+ 
0134:  CLR     180
....................     set_pwm_duty(2, 0);    										// M1 Duty 0%   LEFT- 
0136:  CLR     186
....................     set_pwm_duty(3, 0);   										// M2 Duty 0%   RIGHT- 
0138:  CLR     18C
....................     set_pwm_duty(4, 0);     									// M1 Duty 0%   RIGHT+ 
013A:  CLR     192
.................... } 
013C:  RETURN  
....................  
.................... void Set_Motor_Duty(int16 Left, int16 Right) 
.................... { 
*
0152:  MOV     W5,[W15++]
.................... 	if(Left<0)        
0154:  MOV     870,W4
0156:  CP      W4,#0
0158:  BRA     GE,170
....................     {    
....................  	   if(Left<-PWM_PERIOD )       Left=-PWM_PERIOD ; 
015A:  MOV     870,W4
015C:  MOV     #FA25,W3
015E:  CP      W3,W4
0160:  BRA     LE,166
0162:  MOV     #FA25,W4
0164:  MOV     W4,870
.................... 		set_pwm_duty(1, 0); // M2 Duty 25%  izquierdo 
0166:  CLR     180
.................... 		set_pwm_duty(2, (int16)-Left); // M2 Duty 25%  izquierdo       
0168:  MOV     #0,W4
016A:  MOV     870,W3
016C:  SUB     W4,W3,W5
016E:  MOV     W5,186
.................... 	} 
.................... 	if(Left>=0)        
0170:  MOV     870,W4
0172:  CP      W4,#0
0174:  BRA     LT,188
.................... 	{    
.................... 		if(Left>PWM_PERIOD )       Left=PWM_PERIOD ; 
0176:  MOV     870,W4
0178:  MOV     #5DB,W3
017A:  CP      W3,W4
017C:  BRA     GE,182
017E:  MOV     #5DB,W4
0180:  MOV     W4,870
.................... 		set_pwm_duty(1, (int16)Left); // M2 Duty 25%  izquierdo 
0182:  PUSH    870
0184:  POP     180
.................... 		set_pwm_duty(2, 0); // M2 Duty 25%  izquierdo       
0186:  CLR     186
.................... 	} 
.................... 	if(Right<0) 
0188:  MOV     872,W4
018A:  CP      W4,#0
018C:  BRA     GE,1A4
.................... 	{ 
.................... 		if(Right<-PWM_PERIOD )    Right=-PWM_PERIOD ; 
018E:  MOV     872,W4
0190:  MOV     #FA25,W3
0192:  CP      W3,W4
0194:  BRA     LE,19A
0196:  MOV     #FA25,W4
0198:  MOV     W4,872
.................... 		set_pwm_duty(3, (int16)-Right); // M1 Duty 25%  
019A:  MOV     #0,W4
019C:  MOV     872,W3
019E:  SUB     W4,W3,W5
01A0:  MOV     W5,18C
.................... 		set_pwm_duty(4, 0); // M1 Duty 25%  
01A2:  CLR     192
.................... 	} 
.................... 	if(Right>=0) 
01A4:  MOV     872,W4
01A6:  CP      W4,#0
01A8:  BRA     LT,1BC
.................... 	{ 
.................... 		if(Right>PWM_PERIOD )    Right=PWM_PERIOD ; 
01AA:  MOV     872,W4
01AC:  MOV     #5DB,W3
01AE:  CP      W3,W4
01B0:  BRA     GE,1B6
01B2:  MOV     #5DB,W4
01B4:  MOV     W4,872
.................... 		set_pwm_duty(3, 0); // M1 Duty 25%  
01B6:  CLR     18C
.................... 		set_pwm_duty(4,(int16)Right); // M1 Duty 25%  
01B8:  PUSH    872
01BA:  POP     192
.................... 	} 
.................... } 
01BC:  MOV     [--W15],W5
01BE:  RETURN  
....................  
.................... void Print_Center(int16 center) 
.................... { 
.................... 	if(center<16 && center>=0)  { output_low(PIN_D5);		output_high(PIN_D4);} 
*
03E8:  MOV     870,W4
03EA:  CP      W4,#10
03EC:  BRA     GE,3FC
03EE:  MOV     870,W4
03F0:  CP      W4,#0
03F2:  BRA     LT,3FC
03F4:  BCLR.B  2D2.5
03F6:  BCLR.B  2D6.5
03F8:  BCLR.B  2D2.4
03FA:  BSET.B  2D6.4
.................... 	if(center>16)   			{ output_high(PIN_D5);		output_low(PIN_D4);} 
03FC:  MOV     870,W4
03FE:  CP      W4,#10
0400:  BRA     LE,40A
0402:  BCLR.B  2D2.5
0404:  BSET.B  2D6.5
0406:  BCLR.B  2D2.4
0408:  BCLR.B  2D6.4
.................... 	if(center==16)   			{ output_low(PIN_D5);		output_low(PIN_D4);}  
040A:  MOV     870,W4
040C:  CP      W4,#10
040E:  BRA     NZ,418
0410:  BCLR.B  2D2.5
0412:  BCLR.B  2D6.5
0414:  BCLR.B  2D2.4
0416:  BCLR.B  2D6.4
.................... } 
0418:  RETURN  
....................  
.................... void Read_Sensors_Digital(int16* value_array) 
.................... { 
.................... 	*(value_array+2)=input_state(PIN_B9); 
.................... 	*(value_array+3)=input_state(PIN_B7); 
....................     *(value_array+4)=input_state(PIN_B5); 
.................... 	*(value_array+5)=input_state(PIN_B3); 
.................... 	*(value_array+6)=input_state(PIN_B1); 
.................... 	*(value_array+7)=input_state(PIN_B0); 
.................... 	*(value_array+8)=input_state(PIN_B2); 
.................... 	*(value_array+9)=input_state(PIN_B4); 
.................... 	*(value_array+10)=input_state(PIN_B6); 
.................... 	*(value_array+11)=input_state(PIN_B8); 
.................... 	*(value_array+12)=input_state(PIN_B10); 
.................... } 
....................  
.................... void Read_Sensors(int16* value_array) 
.................... { 
*
01C0:  MOV     W5,[W15++]
.................... 	set_adc_channel(9);  
01C2:  MOV     #9,W4
01C4:  MOV     W4,2A6
.................... 	*(value_array+2)=read_ADC(); 
01C6:  MOV     870,W4
01C8:  ADD     W4,#4,W4
01CA:  MOV     W4,W0
01CC:  MOV     W0,W5
01CE:  BCLR.B  2A0.0
01D0:  BSET.B  2A0.1
01D2:  BTSS.B  2A0.0
01D4:  BRA     1D2
01D6:  MOV     280,W4
01D8:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
01DA:  REPEAT  #91
01DC:  NOP     
.................... 	set_adc_channel(7);  
01DE:  MOV     #7,W4
01E0:  MOV     W4,2A6
.................... 	*(value_array+3)=read_ADC(); 
01E2:  MOV     870,W4
01E4:  ADD     W4,#6,W4
01E6:  MOV     W4,W0
01E8:  MOV     W0,W5
01EA:  BCLR.B  2A0.0
01EC:  BSET.B  2A0.1
01EE:  BTSS.B  2A0.0
01F0:  BRA     1EE
01F2:  MOV     280,W4
01F4:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
01F6:  REPEAT  #91
01F8:  NOP     
.................... 	set_adc_channel(5);  
01FA:  MOV     #5,W4
01FC:  MOV     W4,2A6
.................... 	*(value_array+4)=read_ADC(); 
01FE:  MOV     870,W4
0200:  ADD     W4,#8,W4
0202:  MOV     W4,W0
0204:  MOV     W0,W5
0206:  BCLR.B  2A0.0
0208:  BSET.B  2A0.1
020A:  BTSS.B  2A0.0
020C:  BRA     20A
020E:  MOV     280,W4
0210:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0212:  REPEAT  #91
0214:  NOP     
.................... 	set_adc_channel(3);  
0216:  MOV     #3,W4
0218:  MOV     W4,2A6
.................... 	*(value_array+5)=read_ADC(); 
021A:  MOV     870,W4
021C:  ADD     W4,#A,W4
021E:  MOV     W4,W0
0220:  MOV     W0,W5
0222:  BCLR.B  2A0.0
0224:  BSET.B  2A0.1
0226:  BTSS.B  2A0.0
0228:  BRA     226
022A:  MOV     280,W4
022C:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
022E:  REPEAT  #91
0230:  NOP     
.................... 	set_adc_channel(1);  
0232:  MOV     #1,W4
0234:  MOV     W4,2A6
.................... 	*(value_array+6)=read_ADC(); 
0236:  MOV     870,W4
0238:  ADD     W4,#C,W4
023A:  MOV     W4,W0
023C:  MOV     W0,W5
023E:  BCLR.B  2A0.0
0240:  BSET.B  2A0.1
0242:  BTSS.B  2A0.0
0244:  BRA     242
0246:  MOV     280,W4
0248:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
024A:  REPEAT  #91
024C:  NOP     
.................... 	set_adc_channel(0);			//Center sensor			  
024E:  CLR     2A6
.................... 	*(value_array+7)=read_ADC(); 
0250:  MOV     870,W4
0252:  ADD     W4,#E,W4
0254:  MOV     W4,W0
0256:  MOV     W0,W5
0258:  BCLR.B  2A0.0
025A:  BSET.B  2A0.1
025C:  BTSS.B  2A0.0
025E:  BRA     25C
0260:  MOV     280,W4
0262:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0264:  REPEAT  #91
0266:  NOP     
.................... 	set_adc_channel(2);  
0268:  MOV     #2,W4
026A:  MOV     W4,2A6
.................... 	*(value_array+8)=read_ADC(); 
026C:  MOV     870,W4
026E:  ADD     W4,#10,W4
0270:  MOV     W4,W0
0272:  MOV     W0,W5
0274:  BCLR.B  2A0.0
0276:  BSET.B  2A0.1
0278:  BTSS.B  2A0.0
027A:  BRA     278
027C:  MOV     280,W4
027E:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
0280:  REPEAT  #91
0282:  NOP     
.................... 	set_adc_channel(4);  
0284:  MOV     #4,W4
0286:  MOV     W4,2A6
.................... 	*(value_array+9)=read_ADC(); 
0288:  MOV     870,W4
028A:  ADD     W4,#12,W4
028C:  MOV     W4,W0
028E:  MOV     W0,W5
0290:  BCLR.B  2A0.0
0292:  BSET.B  2A0.1
0294:  BTSS.B  2A0.0
0296:  BRA     294
0298:  MOV     280,W4
029A:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
029C:  REPEAT  #91
029E:  NOP     
.................... 	set_adc_channel(6);  
02A0:  MOV     #6,W4
02A2:  MOV     W4,2A6
.................... 	*(value_array+10)=read_ADC(); 
02A4:  MOV     870,W4
02A6:  ADD     W4,#14,W4
02A8:  MOV     W4,W0
02AA:  MOV     W0,W5
02AC:  BCLR.B  2A0.0
02AE:  BSET.B  2A0.1
02B0:  BTSS.B  2A0.0
02B2:  BRA     2B0
02B4:  MOV     280,W4
02B6:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
02B8:  REPEAT  #91
02BA:  NOP     
.................... 	set_adc_channel(8);  
02BC:  MOV     #8,W4
02BE:  MOV     W4,2A6
.................... 	*(value_array+11)=read_ADC(); 
02C0:  MOV     870,W4
02C2:  ADD     W4,#16,W4
02C4:  MOV     W4,W0
02C6:  MOV     W0,W5
02C8:  BCLR.B  2A0.0
02CA:  BSET.B  2A0.1
02CC:  BTSS.B  2A0.0
02CE:  BRA     2CC
02D0:  MOV     280,W4
02D2:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
02D4:  REPEAT  #91
02D6:  NOP     
.................... 	set_adc_channel(10);  
02D8:  MOV     #A,W4
02DA:  MOV     W4,2A6
.................... 	*(value_array+12)=read_ADC(); 
02DC:  MOV     870,W4
02DE:  ADD     W4,#18,W4
02E0:  MOV     W4,W0
02E2:  MOV     W0,W5
02E4:  BCLR.B  2A0.0
02E6:  BSET.B  2A0.1
02E8:  BTSS.B  2A0.0
02EA:  BRA     2E8
02EC:  MOV     280,W4
02EE:  MOV     W4,[W5+#0]
.................... 	delay_us(5); 
02F0:  REPEAT  #91
02F2:  NOP     
.................... } 
02F4:  MOV     [--W15],W5
02F6:  RETURN  
....................  
.................... void Get_Black_Limit(int16* limit,int st_index,int end_index,int16* array) 
.................... { 
.................... 	int i=0; 
.................... 	int16 min=1024,max=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
.................... 	{	 
.................... 		if(*(array+i)>max) max=*(array+i); 
.................... 		if(*(array+i)<min) min=*(array+i); 
.................... 	} 
.................... 	if((max-min)>204) *limit=min+(max-min)/2;//Limite un 80% arriba del minimo 
.................... } 
....................  
.................... void Digitalize_Array(int16* array_ADC,int16* array_BIN,int16 limit,int st_index,int end_index) 
.................... { 
02F8:  MOV     W5,[W15++]
02FA:  CLR     87A
.................... 	int i=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
02FC:  PUSH    876
02FE:  POP     87A
0300:  MOV     87A,W0
0302:  MOV     878,W4
0304:  CP      W4,W0
0306:  BRA     LT,348
.................... 	{	 
.................... 		if(*(array_ADC+i)>limit) *(array_BIN+i)=0; 
0308:  MOV     87A,W4
030A:  MUL.UU  W4,#2,W0
030C:  MOV     870,W4
030E:  ADD     W0,W4,W0
0310:  MOV     [W0],W5
0312:  MOV     874,W4
0314:  CP      W4,W5
0316:  BRA     GE,326
0318:  MOV     87A,W4
031A:  MUL.UU  W4,#2,W0
031C:  MOV     872,W4
031E:  ADD     W0,W4,W0
0320:  MOV     W0,W5
0322:  MOV     #0,W4
0324:  MOV     W4,[W5+#0]
.................... 		if(*(array_ADC+i)<=limit)*(array_BIN+i)=1; 
0326:  MOV     87A,W4
0328:  MUL.UU  W4,#2,W0
032A:  MOV     870,W4
032C:  ADD     W0,W4,W0
032E:  MOV     [W0],W5
0330:  MOV     874,W4
0332:  CP      W4,W5
0334:  BRA     LT,344
0336:  MOV     87A,W4
0338:  MUL.UU  W4,#2,W0
033A:  MOV     872,W4
033C:  ADD     W0,W4,W0
033E:  MOV     W0,W5
0340:  MOV     #1,W4
0342:  MOV     W4,[W5+#0]
.................... 	} 
0344:  INC     087A
0346:  BRA     300
.................... } 
0348:  MOV     [--W15],W5
034A:  RETURN  
.................... void Get_Average_Center_Digital(int16* array_BIN,int st_index,int end_index,int16* center) 
.................... { 
.................... 	int i=0; 
.................... 	int16 pixels_w=0,values_w=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
.................... 	{	 
.................... 		if(*(array_BIN+i)==1) 
.................... 			{ 
.................... 				values_w=values_w+((i+1)*2); 
.................... 				pixels_w=pixels_w+1; 
.................... 			} 
.................... 	} 
.................... 	if(pixels_w!=0 ) *center=values_w/pixels_w; 
.................... 	else *center=-1; 
.................... } 
....................  
.................... void Get_Average_Center(int16* array_BIN,int st_index,int end_index,int16* center) 
.................... { 
034C:  MOV     W5,[W15++]
034E:  CLR     878
0350:  CLR     87A
0352:  CLR     87C
0354:  CLR     87E
0356:  CLR     880
.................... 	int i=0; 
.................... 	int16 pixels_b=0,values_b=0,pixels_w=0,values_w=0; 
.................... 	for(i=st_index;i<=end_index;i++) 
0358:  PUSH    872
035A:  POP     878
035C:  MOV     878,W0
035E:  MOV     874,W4
0360:  CP      W4,W0
0362:  BRA     LT,3A8
.................... 	{	 
.................... 		if(*(array_BIN+i)==1) 
0364:  MOV     878,W4
0366:  MUL.UU  W4,#2,W0
0368:  MOV     870,W4
036A:  ADD     W0,W4,W0
036C:  MOV     [W0],W5
036E:  CP      W5,#1
0370:  BRA     NZ,384
.................... 			{ 
.................... 				values_w=values_w+((i+1))*2; 
0372:  MOV     878,W4
0374:  ADD     W4,#1,W4
0376:  MOV     W4,W5
0378:  MOV     W5,W4
037A:  MUL.UU  W4,#2,W0
037C:  ADD     880
.................... 				pixels_w=pixels_w+1; 
037E:  MOV     87E,W4
0380:  ADD     W4,#1,W4
0382:  MOV     W4,87E
.................... 			} 
.................... 		if(*(array_BIN+i)==0) 
0384:  MOV     878,W4
0386:  MUL.UU  W4,#2,W0
0388:  MOV     870,W4
038A:  ADD     W0,W4,W0
038C:  MOV     [W0],W5
038E:  CP0     W5
0390:  BRA     NZ,3A4
.................... 			{ 
.................... 				values_b=values_b+((i+1))*2; 
0392:  MOV     878,W4
0394:  ADD     W4,#1,W4
0396:  MOV     W4,W5
0398:  MOV     W5,W4
039A:  MUL.UU  W4,#2,W0
039C:  ADD     87C
.................... 				pixels_b=pixels_b+1; 
039E:  MOV     87A,W4
03A0:  ADD     W4,#1,W4
03A2:  MOV     W4,87A
.................... 			} 
.................... 	} 
03A4:  INC     0878
03A6:  BRA     35C
.................... 	if(pixels_w!=11 && pixels_b!=11 )  
03A8:  MOV     87E,W4
03AA:  CP      W4,#B
03AC:  BRA     Z,3DE
03AE:  MOV     87A,W4
03B0:  CP      W4,#B
03B2:  BRA     Z,3DE
.................... 		{ 
.................... 			if(pixels_w<pixels_b) *center=values_w/pixels_w; 
03B4:  MOV     87E,W0
03B6:  MOV     87A,W4
03B8:  CP      W4,W0
03BA:  BRA     LE,3C8
03BC:  MOV     876,W5
03BE:  MOV     880,W4
03C0:  MOV     87E,W3
03C2:  REPEAT  #11
03C4:  DIV.S   W4,W3
03C6:  MOV     W0,[W5]
.................... 			if(pixels_b<pixels_w) *center=values_b/pixels_b; 
03C8:  MOV     87A,W0
03CA:  MOV     87E,W4
03CC:  CP      W4,W0
03CE:  BRA     LE,3DC
03D0:  MOV     876,W5
03D2:  MOV     87C,W4
03D4:  MOV     87A,W3
03D6:  REPEAT  #11
03D8:  DIV.S   W4,W3
03DA:  MOV     W0,[W5]
.................... 		} 
.................... 	else *center=-1; 
03DC:  BRA     3E4
03DE:  MOV     876,W5
03E0:  MOV     #FFFF,W4
03E2:  MOV     W4,[W5+#0]
.................... } 
03E4:  MOV     [--W15],W5
03E6:  RETURN  
....................  
.................... void Powered_Error(float error, float* correction, float max, float max_c) 
.................... { 
.................... 	float step=1,value; 
.................... 	step=step/max; 
.................... 	if(error!=0) 
.................... 	{ 
.................... 		step=error*step; 
.................... 		value=step*step; 
.................... 		*correction=max_c*value; 
.................... 		if(error<0)	*correction=*correction*-1; 
.................... 	} 
.................... 	else *correction=0; 
.................... 	 
.................... } 
....................  
....................  
.................... void ADC_Init(void); 
.................... void Motor_Init(int16 period); 
.................... void Set_Motor_Duty(int16 Left, int16 Right); 
.................... void Print_Center(int16 center); 
....................  
.................... void Read_Sensors(int16* value_array); 
.................... void Read_Sensors_Digital(int16* value_array); 
.................... void Get_Black_Limit(int16 limit,int st_index,int end_index,int16* array); 
.................... void Digitalize_Array(int16* array_ADC,int16* array_BIN,int16 limit,int st_index,int end_index); 
.................... void Get_Average_Center(int16* array_BIN,int st_index,int end_index,int16* center); 
.................... void Get_Average_Center_Digital(int16* array_BIN,int st_index,int end_index,int16* center); 
.................... void Powered_Error(float error, float* correction, float max, float max_c); 
.................... void Get_Value(float* val); 
.................... void Get_Value_L(int16* val); 
....................  
....................  
.................... void main(void) 
.................... {	 
*
0766:  BSET.B  81.7
0768:  MOV     #2DA,W4
076A:  MOV     W4,81E
076C:  CLR     820
076E:  MOV     #2BC,W4
0770:  MOV     W4,840
0772:  MOV     #10,W4
0774:  MOV     W4,846
0776:  CLR     852
0778:  CLR     854
077A:  CLR     856
077C:  MOV     #43E1,W4
077E:  MOV     W4,858
0780:  CLR     85A
0782:  MOV     #428C,W4
0784:  MOV     W4,85C
0786:  CLR     85E
0788:  MOV     #4100,W4
078A:  MOV     W4,860
078C:  MOV     #FF,W4
078E:  MOV     W4,862
0790:  CLR     864
0792:  MOV     #3E80,W4
0794:  MOV     W4,866
0796:  CLR     868
0798:  SETM    2A8
079A:  MOV     #F80,W15
079C:  MOV     #FFF,W0
079E:  MOV     W0,20
07A0:  NOP     
.................... 	ADC_Init(); 
*
07A4:  CALL    100
.................... 	Motor_Init(PWM_PERIOD); 
07A8:  MOV     #5DB,W4
07AA:  MOV     W4,870
07AC:  CALL    110
.................... 	setup_motor_pwm(3,MPWM_FREE_RUN,64,0,9999);  
07B0:  MOV     #8000,W4
07B2:  MOV     W4,1C0
07B4:  CLR.B   1CA
07B6:  BSET.B  1D0.7
07B8:  MOV     #C,W1
07BA:  MOV     1C0,W2
07BC:  AND     W2,#1C,W2
07BE:  IOR      W1,  W2,W1
07C0:  PUSH    1C0
07C2:  MOV.B   W1L,[W15-#2]
07C4:  POP     1C0
07C6:  MOV     #270F,W4
07C8:  MOV     W4,1C4
....................     set_motor_unit(3,3,MPWM_INDEPENDENT | MPWM_ENABLE_H | MPWM_FAULT_NO_CHANGE,0,0);  
07CA:  MOV     #FBBB,W1
07CC:  MOV     1C8,W2
07CE:  MOV     #440,W3
07D0:  AND     W2,W1,W2
07D2:  IOR      W2,  W3,W2
07D4:  PUSH    1C8
07D6:  MOV.B   W2L,[W15-#2]
07D8:  POP     1C8
07DA:  MOV     #EFCF,W1
07DC:  MOV     1D4,W2
07DE:  MOV     #0,W3
07E0:  AND     W2,W1,W2
07E2:  IOR      W2,  W3,W2
07E4:  PUSH    1D4
07E6:  MOV.B   W2L,[W15-#2]
07E8:  POP     1D4
07EA:  MOV     #CFFB,W1
07EC:  MOV     1D0,W2
07EE:  MOV     #0,W3
07F0:  AND     W2,W1,W2
07F2:  IOR      W2,  W3,W2
07F4:  PUSH    1D0
07F6:  MOV.B   W2L,[W15-#2]
07F8:  POP     1D0
07FA:  MOV.B   #C0,W0L
07FC:  MOV.B   W0L,1CC
07FE:  BCLR.B  1D2.0
0800:  BCLR.B  1D0.0
....................     set_motor_pwm_duty(3,3,910); //set PWM 3 to 1000us  
0802:  MOV     #38E,W4
0804:  MOV     W4,1DA
.................... 	delay_ms(4000); 
0806:  MOV     #FA0,W0
0808:  CALL    13E
....................     set_motor_pwm_duty(3,3,425); //set PWM 3 to 1000us 
080C:  MOV     #1A9,W4
080E:  MOV     W4,1DA
....................     while(true) 
.................... 	{ 
.................... 		Set_Motor_Duty(0,0); 
0810:  CLR     870
0812:  CLR     872
0814:  CALL    152
.................... 		while(!input_state(PIN_D8) )//&& !RUN)   //While loop used for waiting an input high  in D8 to start 
....................    		{ 
0818:  BTSC.B  2D5.0
081A:  BRA     828
.................... 			output_toggle(PIN_D5); 
081C:  BCLR.B  2D2.5
081E:  BTG.B   2D6.5
....................       		delay_ms(250); 
0820:  MOV     #FA,W0
0822:  CALL    13E
....................    		} 
0826:  BRA     818
....................     	set_motor_pwm_duty(3,3,1600); //set PWM 3 to 1000us  
0828:  MOV     #640,W4
082A:  MOV     W4,1DA
.................... 		output_high(PIN_D5); 
082C:  BCLR.B  2D2.5
082E:  BSET.B  2D6.5
.................... 		delay_ms(2000); 
0830:  MOV     #7D0,W0
0832:  CALL    13E
....................  
.................... 		while(RUN){ 
0836:  CP0     862
0838:  BRA     Z,9C2
.................... 			Read_Sensors(sensors_ADC); 
083A:  MOV     #800,W4
083C:  MOV     W4,870
083E:  CALL    1C0
.................... 			Digitalize_Array(Sensors_ADC,Sensors_BIN,Black_Limit,0,14); 
0842:  CLR     876
0844:  MOV     #E,W4
0846:  MOV     W4,878
0848:  MOV     #800,W4
084A:  MOV     W4,870
084C:  MOV     #822,W4
084E:  MOV     W4,872
0850:  PUSH    81E
0852:  POP     874
0854:  CALL    2F8
.................... 			Get_Average_Center(Sensors_BIN,2,12,&Center);   
0858:  MOV     #2,W4
085A:  MOV     W4,872
085C:  MOV     #C,W4
085E:  MOV     W4,874
0860:  MOV     #822,W4
0862:  MOV     W4,870
0864:  MOV     #848,W4
0866:  MOV     W4,876
0868:  CALL    34C
....................  
.................... 			if(center>last_center)center_der=center-last_center; 
086C:  MOV     846,W0
086E:  MOV     848,W4
0870:  CP      W4,W0
0872:  BRA     LE,87E
0874:  MOV     848,W4
0876:  MOV     846,W3
0878:  SUB     W4,W3,W0
087A:  MOV     W0,820
.................... 			else if(last_center>=center)center_der=last_center-center; 
087C:  BRA     88E
087E:  MOV     848,W0
0880:  MOV     846,W4
0882:  CP      W4,W0
0884:  BRA     LT,88E
0886:  MOV     846,W4
0888:  MOV     848,W3
088A:  SUB     W4,W3,W0
088C:  MOV     W0,820
....................  
....................          	if(center==-1 || center_der>16)	center=last_center; 
088E:  MOV     848,W4
0890:  MOV     #FFFF,W3
0892:  CP      W3,W4
0894:  BRA     Z,89C
0896:  MOV     820,W4
0898:  CP      W4,#10
089A:  BRA     LE,8A0
089C:  PUSH    846
089E:  POP     848
.................... 			Print_Center(center); 
08A0:  PUSH    848
08A2:  POP     870
08A4:  CALL    3E8
.................... 		 	last_center=center; 
08A8:  PUSH    848
08AA:  POP     846
....................       	 	error=SET_POINT-center; 
08AC:  MOV     #10,W4
08AE:  MOV     848,W3
08B0:  SUB     W4,W3,W0
08B2:  MOV     W0,84C
.................... 		 	derivative=error-last_error; 
08B4:  MOV     84C,W4
08B6:  MOV     84A,W3
08B8:  SUB     W4,W3,W0
08BA:  MOV     W0,84E
.................... 		 	if(error>4 || error<-4) integral=integral+error; 
08BC:  MOV     84C,W4
08BE:  CP      W4,#4
08C0:  BRA     GT,8CA
08C2:  MOV     84C,W4
08C4:  MOV     #FFFC,W3
08C6:  CP      W3,W4
08C8:  BRA     LE,8E4
08CA:  MOV     84C,W0
08CC:  CALL    41A
08D0:  BCLR.B  43.0
08D2:  MOV     W0,W2
08D4:  MOV     W1,W3
08D6:  MOV     852,W0
08D8:  MOV     854,W1
08DA:  CALL    464
08DE:  MOV     W0,852
08E0:  MOV     W1,854
.................... 			else integral=0; 
08E2:  BRA     8E8
08E4:  CLR     852
08E6:  CLR     854
.................... 			if(integral>120) integral=100; 
08E8:  MOV     #0,W0
08EA:  MOV     #42F0,W1
08EC:  MOV     852,W2
08EE:  MOV     854,W3
08F0:  CALL    604
08F4:  BRA     NC,8FC
08F6:  CLR     852
08F8:  MOV     #42C8,W4
08FA:  MOV     W4,854
.................... 			if(integral*(-1)>120) integral=-100; 
08FC:  MOV     852,W0
08FE:  MOV     854,W1
0900:  MOV     #0,W2
0902:  MOV     #BF80,W3
0904:  CALL    66C
0908:  MOV     W0,W5
090A:  MOV     W1,W6
090C:  MOV     #0,W0
090E:  MOV     #42F0,W1
0910:  MOV     W5,W2
0912:  MOV     W6,W3
0914:  CALL    604
0918:  BRA     NC,920
091A:  CLR     852
091C:  MOV     #C2C8,W4
091E:  MOV     W4,854
.................... 		 	//integral=integral+error; 
.................... 	     	correction=error*(KP)+derivative*(KD)+integral*(KI); 
0920:  MOV     84C,W5
0922:  MOV     W5,W0
0924:  CALL    41A
0928:  MOV     85A,W2
092A:  MOV     85C,W3
092C:  CALL    66C
0930:  MOV     W0,W5
0932:  MOV     W1,W6
0934:  MOV     84E,W7
0936:  MOV     W7,W0
0938:  CALL    41A
093C:  MOV     856,W2
093E:  MOV     858,W3
0940:  CALL    66C
0944:  BCLR.B  43.0
0946:  MOV     W0,W2
0948:  MOV     W1,W3
094A:  MOV     W5,W0
094C:  MOV     W6,W1
094E:  CALL    464
0952:  MOV     W0,W5
0954:  MOV     W1,W6
0956:  MOV     852,W0
0958:  MOV     854,W1
095A:  MOV     85E,W2
095C:  MOV     860,W3
095E:  CALL    66C
0962:  BCLR.B  43.0
0964:  MOV     W0,W2
0966:  MOV     W1,W3
0968:  MOV     W5,W0
096A:  MOV     W6,W1
096C:  CALL    464
0970:  CALL    72A
0974:  MOV     W0,850
.................... 		 	last_error=error; 
0976:  PUSH    84C
0978:  POP     84A
....................  
.................... 		   	if(center>14 && center<18 && BoostCounter<14)  
097A:  MOV     848,W4
097C:  CP      W4,#E
097E:  BRA     LE,99A
0980:  MOV     848,W4
0982:  CP      W4,#12
0984:  BRA     GE,99A
0986:  MOV     868,W4
0988:  CP      W4,#E
098A:  BRA     GE,99A
.................... 			{ 
.................... 				BoostCounter++; 
098C:  INC     0868
.................... 				if(BoostCounter>4) base_speed=1200; //set_motor_pwm_duty(3,3,2500);correction=0 ;//Boost=499-BaseSpeed; 
098E:  MOV     868,W4
0990:  CP      W4,#4
0992:  BRA     LE,998
0994:  MOV     #4B0,W4
0996:  MOV     W4,840
.................... 			}	 
.................... 		    else 
0998:  BRA     9A0
.................... 			{ 
.................... 				BoostCounter=0; base_speed=800;//set_motor_pwm_duty(3,3,2650);}*/ 
099A:  CLR     868
099C:  MOV     #320,W4
099E:  MOV     W4,840
.................... 			} 
....................  
....................          	left_correction=(base_speed)-correction; 
09A0:  MOV     840,W4
09A2:  MOV     850,W3
09A4:  SUB     W4,W3,W0
09A6:  MOV     W0,842
....................      	 	right_correction=(base_speed)+correction;       
09A8:  MOV     840,W0
09AA:  ADD     850,W0
09AC:  MOV     W0,844
.................... 			Set_Motor_Duty(left_correction,right_correction); 
09AE:  PUSH    842
09B0:  POP     870
09B2:  PUSH    844
09B4:  POP     872
09B6:  CALL    152
.................... 	  		delay_us(delay_time); 
09BA:  MOV     866,W0
09BC:  CALL    756
.................... 		} 
09C0:  BRA     836
....................    } 
09C2:  BRA     810
.................... } 
....................  
09C4:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C703   NOCKSFSM FRC_PLL16 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 8733   PUT64 NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN MCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  
